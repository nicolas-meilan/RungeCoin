diff --git a/node_modules/bip39/src/index.js b/node_modules/bip39/src/index.js
index 91d1a72..49c3e82 100644
--- a/node_modules/bip39/src/index.js
+++ b/node_modules/bip39/src/index.js
@@ -1,8 +1,9 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-const createHash = require("create-hash");
-const pbkdf2_1 = require("pbkdf2");
-const randomBytes = require("randombytes");
+global.Buffer = global.Buffer || require('buffer').Buffer
+const { NativeModules } = require('react-native')
+const Aes = NativeModules.Aes
+const { randomBytes, createHash, pbkdf2Sync } = require('react-native-crypto')
 const _wordlists_1 = require("./_wordlists");
 let DEFAULT_WORDLIST = _wordlists_1._default;
 const INVALID_MNEMONIC = 'Invalid mnemonic';
@@ -10,18 +11,11 @@ const INVALID_ENTROPY = 'Invalid entropy';
 const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
 const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
     'Please pass a 2048 word array explicitly.';
-function pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {
-    return Promise.resolve().then(() => new Promise((resolve, reject) => {
-        const callback = (err, derivedKey) => {
-            if (err) {
-                return reject(err);
-            }
-            else {
-                return resolve(derivedKey);
-            }
-        };
-        pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);
-    }));
+function pbkdf2Promise(password, saltMixin, iterations, keylen) {
+    return Promise.resolve().then(() => new Promise((resolve, reject) => Aes.pbkdf2(password.toString('utf8'), saltMixin.toString('utf8'), iterations, keylen)
+        .then((seed) => resolve(global.Buffer.from(seed, "hex")))
+        .catch(reject)
+    ));
 }
 function normalize(str) {
     return (str || '').normalize('NFKD');
@@ -52,14 +46,14 @@ function salt(password) {
 function mnemonicToSeedSync(mnemonic, password) {
     const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
     const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
-    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
+    return pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
 }
 exports.mnemonicToSeedSync = mnemonicToSeedSync;
 function mnemonicToSeed(mnemonic, password) {
     return Promise.resolve().then(() => {
         const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
         const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
-        return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
+        return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 512);
     });
 }
 exports.mnemonicToSeed = mnemonicToSeed;
@@ -75,12 +69,12 @@ function mnemonicToEntropy(mnemonic, wordlist) {
     // convert word indices to 11 bit binary strings
     const bits = words
         .map((word) => {
-        const index = wordlist.indexOf(word);
-        if (index === -1) {
-            throw new Error(INVALID_MNEMONIC);
-        }
-        return lpad(index.toString(2), '0', 11);
-    })
+            const index = wordlist.indexOf(word);
+            if (index === -1) {
+                throw new Error(INVALID_MNEMONIC);
+            }
+            return lpad(index.toString(2), '0', 11);
+        })
         .join('');
     // split the binary string into ENT/CS
     const dividerIndex = Math.floor(bits.length / 33) * 32;